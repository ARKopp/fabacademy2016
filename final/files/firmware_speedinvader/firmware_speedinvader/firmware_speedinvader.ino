#include <font6x8.h>
#include <font8x16.h>
#include <num2str.h>
#include <ssd1306xled.h>
#include <ssd1306xled8x16.h>

#include "SSD1306_minimal.h"

#include <avr/pgmspace.h>
#include "bitmap.h"
#define DEG "\xa7" "C"

#define HALL_SENSOR_PIN     4
#define DEBOUNCE_INTERVAL  20   // ms
#define UMFANG 0.187 // m

volatile byte half_revolutions;
unsigned int rpm;
float kmh;
float mph;
float max_kmh;

unsigned long timeold;
bool last_reading;  // the old state of the hall sensor input
unsigned long last_interrupt_at;  // the time of the last LOW to HIGH

SSD1306_Mini oled;


//Byte array of bitmap of 76 x 56 px:
const unsigned char img_logo [] PROGMEM = {
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x30, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x07, 0xc3, 0xe3, 0xe3, 0xe3, 0xe3, 0xc3, 0x07, 0x0f, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xf0, 0xe1, 0xc3, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xff, 0xff, 0xff, 0xf0, 0xe0, 0xe3, 0xc7, 0xc7, 0xc7, 0xc7, 0xe3, 0xe0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe3, 0xe3, 0xe3, 0xe3, 0xe3, 0xe3, 0x03, 0x7f, 0x7f, 0x7f, 0x7f, 0x03, 0xe3, 0x03, 0x7f, 0x7f, 0x7f, 0x03, 0xe3, 0x03, 0x7f, 0x7f, 0x7f, 0x7f, 0x03, 0xe3, 0xe3, 0xe3, 0xe3, 0xe3, 0xe3, 0x00, 0x00, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x0f, 0x1f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x8f, 0x8f, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x8f, 0x8f, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0xc0, 0xc0, 0xf0, 0xff, 0xff, 0xf9, 0xf1, 0x01, 0x01, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xf1, 0x01, 0x01, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x01, 0x03, 0xe3, 0xf1, 0xf1, 0xf1, 0xf1, 0x01, 0x03, 0xff, 0xff, 0xff, 0xff, 0x07, 0x03, 0xe1, 0xf1, 0xf1, 0xf1, 0xf1, 0xe1, 0x03, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xe3, 0xe0, 0xe0, 0xe0, 0xe3, 0xe3, 0xf7, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xe3, 0xe0, 0xe0, 0xe0, 0xe3, 0xe3, 0xf7, 0xff, 0xff, 0xf0, 0xe0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xf0, 0xf1, 0xe3, 0xe3, 0xe3, 0xe3, 0xf1, 0xf0, 0xf8, 0xff, 0xff, 0xff, 0xff
};

//byte array of bitmap 17x16 px
const unsigned char  img_heart_big[] PROGMEM = {

    0xe0, 0xf0, 0xf8, 0xf8, 0xf8, 0xf8, 0xf0, 0xe0, 0xe0, 0xe0, 0xf0, 0xf8, 0xf8, 0xf8, 0xf8, 0xf0, 0xe0, 0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01, 0x00
};

//byte array of bitmap 17x16 px
const unsigned char  img_heart_small[] PROGMEM = {

    0x00, 0x00, 0xc0, 0xe0, 0xe0, 0xe0, 0xc0, 0x80, 0x80, 0x80, 0xc0, 0xe0, 0xe0, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00
};


void setup()
{
  pinMode(HALL_SENSOR_PIN, INPUT);
  //digitalWrite(4, HIGH);
  //attachInterrupt(EXTERNAL_INTERRUPT_4, rpm_fun, FALLING);
  pinMode(0, OUTPUT);
  pinMode(1, OUTPUT);

  delay(500);
  digitalWrite(1, HIGH);
  delay(500);
  digitalWrite(1, LOW);
  delay(500);

  oled.init(0x3c);
  oled.clear();
  

  
  half_revolutions = 0;
  rpm = 0;
  kmh = 0;
  mph = 0;
  max_kmh = 0;
  timeold = 0;
  last_reading = 1;

  // Welcome Screen
  oled.startScreen();
  oled.clear();
  oled.cursorTo(0,0);
  oled.printString("Hallo");
  delay(1000);
  oled.cursorTo(0,1);
  oled.printString("I am");
  delay(1000);
  oled.cursorTo(0,2);
  delay(1000);
  oled.printString("speedinvader");
  delay(1000);
  oled.cursorTo(0,3);
  delay(1000);
  oled.printString("I am");
  delay(1000);
  oled.cursorTo(0,4);
  delay(1000);
  oled.printString("alive");
  delay(1000);
  oled.clear();
 
  
  
}

void loop()
{
  //oled.cursorTo(0,3);
  //oled.printString("speedinvader");;
  delay(1000);
  heartBeat();
  bool reading = digitalRead(HALL_SENSOR_PIN);
  if (reading && !last_reading                              // Pin state changed from LOW to HIGH
      && millis() - last_interrupt_at > DEBOUNCE_INTERVAL)  // debounce
  {
    half_revolutions++;
    last_interrupt_at = millis();
    digitalWrite(1, HIGH);
    delay(20);
    digitalWrite(1, LOW);
  }
  last_reading = reading;
  
  if (half_revolutions >= 5) { 
    //Update RPM every 20 counts, increase this for better RPM resolution,
    //decrease for faster update
    unsigned long now = millis();
    rpm = 60000/(now - timeold)*half_revolutions;
    kmh = ((rpm*UMFANG)/60)*3.6;
    mph = kmh*0.621371;
    if (kmh > max_kmh) {
      max_kmh = kmh;
    }
    
    timeold = now;
    half_revolutions = 0;
    
    // Calculate and display RPM
    char rpm_char[10];
    String rpm_string;
    rpm_string = String(rpm) + " RPM";
    rpm_string.toCharArray(rpm_char, 10);
    oled.cursorTo(0, 0);
    oled.printString(rpm_char);

    // Calculate and display km/h
    char kmh_char[10];
    String kmh_string;
    kmh_string = String(int(kmh)) + " km/h";
    kmh_string.toCharArray(kmh_char, 10);
    oled.cursorTo(0, 1);
    oled.printString(kmh_char);

    // Calculate and display mp/h #
    char mph_char[10];
    String mph_string;
    mph_string = String(int(mph)) + " mp/h";
    mph_string.toCharArray(mph_char, 10);
    oled.cursorTo(0, 2);
    oled.printString(mph_char);

    // Calculate and display max km/h
    char max_kmh_char[10];
    String max_kmh_string;
    max_kmh_string = String(int(max_kmh)) + " km/h maxs";
    max_kmh_string.toCharArray(max_kmh_char, 10);
    oled.cursorTo(0, 3);
    oled.printString(max_kmh_char);
  }
}


// RetroWatch splash screen
void heartBeat(){
  static char big=1;
  static long startTime=0;
  long currentTime;

  // get current time
  currentTime= millis();
  
  // update if 1000ms passed  
  if ((currentTime - startTime) > 200){
    startTime= currentTime;  


    // --- 
    big=1-big;
    if (big){
      oled.drawImage( img_heart_big, 10, 5, 17, 2);      
    } else {
      oled.drawImage( img_heart_small, 10, 5, 17, 2);
    }
  
  }  
}



